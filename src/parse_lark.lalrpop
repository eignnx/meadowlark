use crate::ast::{
    Item,
    AliasBinding,
    LValue,
    Stmt,
    Instr,
    Arg,
    Reg,
};

grammar;

pub Program: Vec<Item> = {
    <items: Item*> => items,
};



Item: Item = {
    "def" <name: LabelIdent> ":" "u16" "=" <value: Unsigned> ";" => Item::Const { name, value },
    "fn" <fn_name: LabelIdent> "("
        <args: (AliasBinding ("," <AliasBinding>)*)?>
    ")" <save_regs: ("preserve" "("
        <(Reg ("," <Reg>)*)?>
    ")")?> "{" <body: Stmt*> "}" => Item::FnDef {
        name: fn_name,

        args: args.map(|(first, rest)| {
            std::iter::once(first).chain(rest.into_iter()).collect()
        }).unwrap_or_default(),

        preserve_regs: save_regs.map(|opt| {
            match opt {
                Some((first, rest)) => {
                    std::iter::once(first).chain(rest.into_iter()).collect()
                },
                None => vec![],
            }
        }).unwrap_or_default(),

        body,
    },
}

AliasBinding: AliasBinding = {
    <name: LabelIdent> "=>" <lvalue: LValue> => AliasBinding::ExplicitAlias(name.to_string(), lvalue),
    <name: LabelIdent> => AliasBinding::ImpliedAlias(name.to_string()),
};

LValue: LValue = {
    <reg: Reg> => LValue::Reg(reg),
    "[" <reg: Reg> <offset: Signed> "]" => LValue::Mem(reg, offset),
    "[" <addr: Unsigned> "]" => LValue::Mem(Reg::Zero, addr as i16),
    "[" <reg: Reg> "]" => LValue::Mem(reg, 0),
};

Stmt: Stmt = {
    "restore" ";" => Stmt::Restore,
    "alias" <alias: LabelIdent> "=>" <lvalue: LValue> ";" => Stmt::DefAlias(alias.to_string(), lvalue),
    <instr: Instr> ";" => Stmt::Instr(instr),
    <label: LabelIdent> r":" => Stmt::Label(label.to_string()),
    <if_stmt: IfStmt> => if_stmt,
    <while_loop: WhileLoop> => while_loop,
};

IfStmt: Stmt = {
    "if" <test_reg: Reg> "("
        <first: Instr> <rest_test_cond: RestTestCond?>
    ")" "do" "{"
        <then_body: Stmt*>
    "}" <else_body: ("else" "{"
         <Stmt*>
    "}")?> => Stmt::If {
        test_reg,
        test_cond: std::iter::once(first).chain(rest_test_cond.into_iter().flatten()).collect(),
        consequent: then_body,
        alternative: else_body,
    },
};

WhileLoop: Stmt = {
    "while" <test_reg: Reg> "(" <first: Instr> <rest_test_cond: RestTestCond?> ")" "do" "{" <body: Stmt*> "}" => Stmt::While {
        test_reg,
        test_cond: std::iter::once(first).chain(rest_test_cond.into_iter().flatten()).collect(),
        body,
    },
};

RestTestCond: Vec<Instr> = {
    <instrs: (";" <Instr>)+> ";" => instrs,
};

Instr: Instr = {
    <op: OpName> => Instr { op, args: vec![] },
    <op: OpName> <fst: Arg> <rest: ("," <Arg>)*> => {
        let args = std::iter::once(fst).chain(rest.into_iter()).collect();
        Instr { op, args }
    },
};

LabelIdent: String = <id: r#"[a-zA-Z_.][a-zA-Z0-9_.]*"#> => id.to_string();
OpName: String = <op: r"![a-z]+"> => op[1..].to_string();

Arg: Arg = {
    <reg: Reg> => Arg::Reg(reg),
    <i: ImmOrOffset> => i,
    r"@" <label: LabelIdent> => Arg::Label(label.to_string()),
    <var_name: LabelIdent> => Arg::Alias(var_name.to_string()),
};

ImmOrOffset: Arg = {
    "[" <reg: Reg> "+" <imm: Unsigned> "]" => Arg::Offset(imm as i16, reg),
    "[" <reg: Reg> "-" <imm: Unsigned> "]" => Arg::Offset(-(imm as i16), reg),
    "[" <reg: Reg> "]" => Arg::Offset(0, reg),
    "[" <imm: Unsigned> "]" => Arg::Offset(imm as i16, Reg::Zero),
    "[" <var_name: LabelIdent> "]" => Arg::AliasIndirection(var_name.to_string()),
    <imm: Integer> => imm,
};

Integer: Arg = {
    <u: Unsigned> => Arg::Uint(u),
    <i: Signed> => Arg::Int(i),
};

Unsigned: u16 = {
    <n: r"0x[0-9a-fA-F]+"> => {
        let n = &n[2..].to_ascii_lowercase();
        return u16::from_str_radix(n, 16).expect("parse hexadecimal number");
    },
    <n: r"0b[01]+"> => {
        let n = &n[2..].to_ascii_lowercase();
        return u16::from_str_radix(n, 2).expect("parse binary number");
    },
    <n: r"[0-9]+"> => n.parse().unwrap(),
};

Signed: i16 = {
    <n: r"\+[0-9]+"> => n.parse().unwrap(),
    <n: r"\-[0-9]+"> => n.parse().unwrap(),
}

Reg: Reg = {
    <name: r"\$[a-z]+"> <id: r"[0-9]+"?> => {
        let name = name[1..].to_string(); // remove the "$" from the name
        if let Some(id) = id {
            let id = id.parse().unwrap();
            match (&name[..], id) {
                ("a", 0..=2) => Reg::Arg(id),
                ("s", 0..=2) => Reg::Saved(id),
                ("t", 0..=2) => Reg::Temp(id),
                ("k", 0..=1) => Reg::Kernel(id),
                _ => panic!("unknown register: `${}{}`", name, id),
            }
        } else {
            match &name[..] {
                "zero" => Reg::Zero,
                "rv" => Reg::Rv,
                "ra" => Reg::Ra,
                "gp" => Reg::Gp,
                "sp" => Reg::Sp,
                _ => panic!("unknown register: {}", name),
            }
        }
    }
};